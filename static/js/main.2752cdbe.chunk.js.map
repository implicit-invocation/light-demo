{"version":3,"sources":["light/Board.js","light/BoardRenderer.js","light/BoardHandler.js","index.js"],"names":["Board","cellTypes","columnCount","this","cellStates","map","i","clicked","cellCount","length","toggleListeners","history","push","Math","floor","random","func","filter","f","index","count","silent","hit","step","x","y","noChain","rowCount","ceil","toggle","toggleXY","fireEvent","type","bind","pop","undo","REGION_NAMES","BoardRenderer","width","height","pad","padX","padY","gridSize","effects","board","addToggleListener","duration","startTime","Date","now","delay","batch","altas","getWidth","drawSize","cellType","regionIndex","regionName","region","findRegion","drawScale","max","draw","fx","state","setColor","getHeight","splice","drawFx","drawCell","createBoardHandler","inputHandler","enabled","addEventListener","getTouchedWorldCoord","enable","disable","setBoard","newBoard","loadSound","src","Promise","resolve","sound","Howl","onload","a","stage","createStage","canvas","getCanvas","info","getInfo","loader","document","getElementById","viewport","createViewport","crop","gl","getContext","camera","getCamera","createViewportAwareInputHandler","createBatch","loadAtlas","atlas","renderer","handler","click","win","shuffle","isWinning","play","remove","fading","fadeFrame","fadeSpeed","fadeSize","circle","clearColor","loop","createGameLoop","delta","clear","COLOR_BUFFER_BIT","setProjection","combined","begin","render","end","setInterval","innerHTML","getFps","style","display","init"],"mappings":"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","file":"static/js/main.2752cdbe.chunk.js","sourcesContent":["export default class Board {\n  static random(cellCount, columnCount) {\n    const cellTypes = [];\n    for (var i = 0; i < cellCount; i++) {\n      cellTypes.push(Math.floor(Math.random() * 4));\n    }\n    return new Board(cellTypes, columnCount);\n  }\n\n  constructor(cellTypes, columnCount) {\n    this.cellTypes = cellTypes;\n    this.cellStates = cellTypes.map(i => true);\n    this.clicked = cellTypes.map(i => false);\n    this.columnCount = columnCount;\n    this.cellCount = cellTypes.length;\n    this.toggleListeners = [];\n    this.history = [];\n  }\n\n  getWidth() {\n    return this.columnCount;\n  }\n\n  getHeight() {\n    return this.cellCount / this.columnCount;\n  }\n\n  addToggleListener(func) {\n    this.toggleListeners.push(func);\n    return () => {\n      this.toggleListeners = this.toggleListeners.filter(f => f !== func);\n    };\n  }\n\n  toggle(index) {\n    if (index >= 0 && index < this.cellCount) {\n      this.cellStates[index] = !this.cellStates[index];\n    }\n  }\n\n  isWinning() {\n    for (var i = 0; i < this.cellStates.length; i++) {\n      if (!this.cellStates[i]) return false;\n    }\n    return true;\n  }\n\n  shuffle(count) {\n    let i = 0;\n    this.silent = true;\n    while (i < count) {\n      const index = Math.floor(Math.random() * this.cellCount);\n      if (!this.clicked[index]) {\n        this.hit(index);\n        i++;\n      }\n    }\n    this.silent = false;\n    this.history.length = 0;\n  }\n\n  fireEvent(index, step) {\n    if (this.silent) return;\n    this.toggleListeners.map(func => func(index, step));\n  }\n\n  toggleXY(x, y, noChain, step) {\n    const columnCount = this.columnCount;\n    const rowCount = Math.ceil(this.cellCount / columnCount);\n    if (x >= 0 && x < columnCount && y >= 0 && y < rowCount) {\n      const index = y * columnCount + x;\n      this.toggle(index);\n      if (!noChain) {\n        switch (this.cellTypes[index]) {\n          case 1:\n            this.toggleXY(x, y - 1, true, step + 1);\n            break;\n          case 2:\n            this.toggleXY(x, y + 1, true, step + 1);\n            break;\n          case 3:\n            this.toggleXY(x - 1, y, true, step + 1);\n            break;\n          case 4:\n            this.toggleXY(x + 1, y, true, step + 1);\n            break;\n          default:\n        }\n        this.fireEvent(index, step);\n      }\n    }\n  }\n\n  hit(index) {\n    this.history.push(index);\n    this.clicked[index] = !this.clicked[index];\n    const x = index % this.columnCount;\n    const y = Math.floor(index / this.columnCount);\n    const type = this.cellTypes[index];\n    const toggleXY = this.toggleXY.bind(this);\n\n    switch (type) {\n      case 0:\n        toggleXY(x, y, true, 0);\n        toggleXY(x + 1, y, false, 0);\n        toggleXY(x - 1, y, false, 0);\n        toggleXY(x, y + 1, false, 0);\n        toggleXY(x, y - 1, false, 0);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        toggleXY(x + 1, y, false, 0);\n        toggleXY(x - 1, y, false, 0);\n        toggleXY(x, y + 1, false, 0);\n        toggleXY(x, y - 1, false, 0);\n        break;\n      default:\n    }\n\n    this.fireEvent(index, -1);\n  }\n\n  undo() {\n    if (this.history.length !== 0) {\n      this.hit(this.history.pop());\n      this.history.pop();\n    }\n  }\n\n  reset() {\n    this.silent = true;\n    while (this.history.length > 0) {\n      this.undo();\n    }\n    this.silent = false;\n  }\n}\n","const REGION_NAMES = ['circle', 'up', 'down', 'left', 'right'];\n\nexport default class BoardRenderer {\n  padX = 0;\n  padY = 0;\n  gridSize = 0;\n  effects = [];\n  constructor(width, height, pad = 0) {\n    this.width = width;\n    this.height = height;\n\n    if (width > height) {\n      this.gridSize = (height - 2 * pad) / 4;\n      this.padY = pad;\n      this.padX = pad + (width - height) / 2;\n    } else {\n      this.gridSize = (width - 2 * pad) / 4;\n      this.padX = pad;\n      this.padY = pad + (height - width) / 2;\n    }\n  }\n  setBoard(board) {\n    this.board = board;\n    board.addToggleListener((index, step) => {\n      if (step === -1) {\n        this.effects.push({\n          type: 0,\n          index,\n          duration: 500,\n          startTime: Date.now(),\n          delay: 0\n        });\n      } else if (step === 0 && board.cellTypes[index] !== 0) {\n        this.effects.push({\n          type: board.cellTypes[index],\n          index,\n          duration: 500,\n          startTime: Date.now(),\n          delay: 50\n        });\n      }\n    });\n  }\n\n  drawCell(x, y, batch, altas) {\n    const { board, gridSize, padX, padY } = this;\n\n    const width = board.getWidth();\n\n    const index = y * width + x;\n\n    const drawSize = gridSize * 0.8;\n\n    const cellType = board.cellTypes[index];\n    const cellState = board.cellStates[index];\n\n    const regionIndex = cellState ? 1 : 0;\n    const regionName = REGION_NAMES[cellType];\n\n    // TODO: cache this\n    const region = altas.findRegion(regionName, regionIndex);\n    const drawScale = drawSize / Math.max(region.width, region.height);\n\n    region.draw(\n      batch,\n      padX + x * gridSize - region.width / 2 + gridSize / 2,\n      padY + y * gridSize - region.height / 2 + gridSize / 2,\n      region.width,\n      region.height,\n      region.width / 2,\n      region.height / 2,\n      0,\n      drawScale,\n      drawScale\n    );\n  }\n\n  drawFx(fx, batch, altas) {\n    const { board, gridSize, padX, padY } = this;\n\n    const state = (Date.now() - fx.startTime) / fx.duration;\n\n    const width = board.getWidth();\n\n    const x = fx.index % width;\n    const y = Math.floor(fx.index / width);\n\n    const drawSize = gridSize * 0.8;\n    const regionName = REGION_NAMES[fx.type];\n    const region = altas.findRegion(regionName, 1);\n    const drawScale = drawSize / Math.max(region.width, region.height);\n\n    batch.setColor(1, 1, 1, 1 - state);\n    switch (fx.type) {\n      case 1:\n        region.draw(\n          batch,\n          padX + x * gridSize - region.width / 2 + gridSize / 2,\n          padY +\n            y * gridSize -\n            region.height / 2 +\n            gridSize / 2 -\n            state * gridSize,\n          region.width,\n          region.height,\n          region.width / 2,\n          region.height / 2,\n          0,\n          drawScale,\n          drawScale\n        );\n        break;\n      case 2:\n        region.draw(\n          batch,\n          padX + x * gridSize - region.width / 2 + gridSize / 2,\n          padY +\n            y * gridSize -\n            region.height / 2 +\n            gridSize / 2 +\n            state * gridSize,\n          region.width,\n          region.height,\n          region.width / 2,\n          region.height / 2,\n          0,\n          drawScale,\n          drawScale\n        );\n        break;\n      case 3:\n        region.draw(\n          batch,\n          padX +\n            x * gridSize -\n            region.width / 2 +\n            gridSize / 2 -\n            state * gridSize,\n          padY + y * gridSize - region.height / 2 + gridSize / 2,\n          region.width,\n          region.height,\n          region.width / 2,\n          region.height / 2,\n          0,\n          drawScale,\n          drawScale\n        );\n        break;\n      case 4:\n        region.draw(\n          batch,\n          padX +\n            x * gridSize -\n            region.width / 2 +\n            gridSize / 2 +\n            state * gridSize,\n          padY + y * gridSize - region.height / 2 + gridSize / 2,\n          region.width,\n          region.height,\n          region.width / 2,\n          region.height / 2,\n          0,\n          drawScale,\n          drawScale\n        );\n        break;\n      default:\n        batch.setColor(1, 1, 1, (1 - state) / 2);\n        region.draw(\n          batch,\n          padX + x * gridSize - region.width / 2 + gridSize / 2,\n          padY + y * gridSize - region.height / 2 + gridSize / 2,\n          region.width,\n          region.height,\n          region.width / 2,\n          region.height / 2,\n          0,\n          drawScale * (1.3 / Math.max(0.3, 1 - state)),\n          drawScale * (1.3 / Math.max(0.3, 1 - state))\n        );\n    }\n    batch.setColor(1, 1, 1, 1);\n  }\n\n  render(batch, altas) {\n    const { board, effects } = this;\n    const width = board.getWidth();\n    const height = board.getHeight();\n\n    const now = Date.now();\n    for (let i = effects.length - 1; i >= 0; i--) {\n      const fx = effects[i];\n      if (now - fx.startTime > fx.duration) {\n        effects.splice(i, 1);\n      }\n    }\n\n    for (let fx of effects) {\n      if (now - fx.startTime >= fx.delay) {\n        this.drawFx(fx, batch, altas);\n      }\n    }\n\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        this.drawCell(x, y, batch, altas);\n      }\n    }\n  }\n}\n","const createBoardHandler = (width, height, pad, inputHandler) => {\n  let board;\n  let gridSize, padX, padY;\n  let enabled = true;\n  if (width > height) {\n    gridSize = (height - 2 * pad) / 4;\n    padY = pad;\n    padX = pad + (width - height) / 2;\n  } else {\n    gridSize = (width - 2 * pad) / 4;\n    padX = pad;\n    padY = pad + (height - width) / 2;\n  }\n\n  inputHandler.addEventListener('touchStart', () => {\n    if (!board || !enabled) return;\n    let { x, y } = inputHandler.getTouchedWorldCoord();\n    x = Math.floor((x - padX) / gridSize);\n    y = Math.floor((y - padY) / gridSize);\n\n    if (x < 0 || x > 3 || y < 0 || y > 3) {\n      return;\n    }\n    board.hit(x + y * board.getWidth());\n  });\n\n  return {\n    enable() {\n      enabled = true;\n    },\n    disable() {\n      enabled = false;\n    },\n    setBoard(newBoard) {\n      board = newBoard;\n    }\n  };\n};\n\nexport default createBoardHandler;\n","import './index.css';\n\nimport Board from './light/Board';\nimport BoardRenderer from './light/BoardRenderer';\nimport {\n  createStage,\n  createViewport,\n  createBatch,\n  loadAtlas,\n  createGameLoop,\n  createViewportAwareInputHandler\n} from 'gdxjs';\nimport createBoardHandler from './light/BoardHandler';\nimport { Howl } from 'howler';\n\nconst loadSound = src =>\n  new Promise(resolve => {\n    const sound = new Howl({\n      src: [src],\n      onload: () => resolve(sound)\n    });\n  });\n\nconst init = async () => {\n  const stage = createStage();\n  const canvas = stage.getCanvas();\n  const info = stage.getInfo();\n  const loader = document.getElementById('loader');\n\n  const [width, height] = [60, 100];\n  const pad = 10;\n\n  const viewport = createViewport(canvas, width, height, {\n    crop: false\n  });\n  const gl = viewport.getContext();\n  const camera = viewport.getCamera();\n  const inputHandler = createViewportAwareInputHandler(canvas, viewport);\n\n  const batch = createBatch(gl);\n  const atlas = await loadAtlas(gl, './symbol-78.atlas');\n\n  const renderer = new BoardRenderer(width, height, pad);\n  const handler = createBoardHandler(width, height, pad, inputHandler);\n\n  const click = await loadSound('./click.mp3');\n  const win = await loadSound('./win.mp3');\n\n  let board;\n  const newBoard = () => {\n    board = Board.random(16, 4);\n    board.shuffle(3);\n    renderer.setBoard(board);\n    handler.setBoard(board);\n    board.addToggleListener((index, step) => {\n      if (step === -1 && !board.isWinning()) {\n        click.play();\n      }\n    });\n  };\n  newBoard();\n\n  loader.remove();\n\n  const FADE_SPEED = 2;\n\n  let fading = false;\n  let fadeFrame = 0;\n  let fadeSpeed = FADE_SPEED;\n  let fadeSize = Math.max(width, height) * 10;\n\n  const circle = atlas.findRegion('circle', 1);\n\n  gl.clearColor(0, 0, 0, 0);\n  const loop = createGameLoop(delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    batch.setProjection(camera.combined);\n    batch.begin();\n    if (!fading && board.isWinning()) {\n      win.play();\n      fading = true;\n      handler.disable();\n    }\n    if (fading) {\n      fadeFrame += fadeSpeed;\n      if (fadeFrame >= 60) {\n        fadeSpeed = -FADE_SPEED;\n        fadeFrame = 60;\n        newBoard();\n      }\n      if (fadeFrame <= 0) {\n        fadeFrame = 0;\n        fadeSpeed = FADE_SPEED;\n        fading = false;\n        handler.enable();\n      }\n      batch.setColor(1, 1, 1, 1 - (60 - fadeFrame) / 60);\n\n      circle.draw(batch, width / 2 - fadeSize / 2, height / 2 - fadeSize / 2, fadeSize, fadeSize);\n      batch.setColor(1, 1, 1, 1);\n    }\n    renderer.render(batch, atlas);\n    batch.end();\n  });\n\n  setInterval(() => (info.innerHTML = `FPS: ${loop.getFps()}`), 500);\n  if (process.env.NODE_ENV && process.env.NODE_ENV !== 'development') {\n    info.style.display = 'none';\n  }\n};\n\ninit();\n"],"sourceRoot":""}